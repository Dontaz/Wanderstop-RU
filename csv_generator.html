<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>CSV Локализатор: Обновление ВСЕХ полей</title>
    <style>
        body { font-family: "Segoe UI", sans-serif; max-width: 900px; margin: 20px auto; padding: 20px; color: #333; }
        .section { background: #f4f4f4; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        label { display: block; margin-top: 10px; font-weight: bold; }
        select, input[type="file"] { margin-top: 5px; width: 100%; padding: 8px; box-sizing: border-box; }
        button { background-color: #28a745; color: white; border: none; padding: 12px; width: 100%; margin-top: 15px; cursor: pointer; border-radius: 4px; font-size: 16px; }
        button:hover { background-color: #218838; }
        
        #logArea { 
            width: 100%; height: 200px; 
            background: #222; color: #eee; 
            font-family: monospace; font-size: 12px; 
            padding: 10px; box-sizing: border-box; 
            border: 1px solid #000; overflow-y: scroll;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <h1>CSV Локализатор (Full Update)</h1>
    <p><i>Эта версия обновляет English_US, Description и Russian, если вы изменили их в таблице.</i></p>

    <!-- 1. ЭКСПОРТ -->
    <div class="section">
        <h2>1. Экспорт в таблицу</h2>
        <label>Разделитель:</label>
        <select id="sepExport">
            <option value=",">Запятая (,)</option>
            <option value=";">Точка с запятой (;)</option>
            <option value="	">Табуляция (Tab)</option>
        </select>
        <input type="file" id="sourceFileExport">
        <button onclick="processExport()" style="background-color: #007bff;">Скачать таблицу</button>
    </div>

    <!-- 2. ИМПОРТ -->
    <div class="section">
        <h2>2. Слияние (Full Update)</h2>
        <label>Разделитель:</label>
        <select id="sepImport">
            <option value=",">Запятая (,)</option>
            <option value=";">Точка с запятой (;)</option>
            <option value="	">Табуляция (Tab)</option>
        </select>
        
        <label>1. Оригинальный файл (Вертикальный):</label>
        <input type="file" id="originalFileImport">
        
        <label>2. Файл с правками (Таблица):</label>
        <input type="file" id="translatedFileImport">
        
        <button onclick="processMerge()">Обновить оригинал</button>
    </div>

    <h3>Журнал работы:</h3>
    <div id="logArea">Готов к работе...</div>

    <script>
        function log(msg, color = '#eee') {
            const logArea = document.getElementById('logArea');
            logArea.innerHTML += `<div style="color:${color};">> ${msg}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
        }
        function clearLog() { document.getElementById('logArea').innerHTML = ''; }

        function cleanStr(str) {
            if (str === null || str === undefined) return "";
            return String(str).replace(/^\uFEFF/, '').replace(/\u00A0/g, ' ').trim();
        }

        function parseCSV(text, separator) {
            const rows = [];
            let currentRow = [];
            let currentVal = '';
            let insideQuotes = false;
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === '"') {
                    if (insideQuotes && text[i+1] === '"') { currentVal += '"'; i++; }
                    else { insideQuotes = !insideQuotes; }
                } else if (char === separator && !insideQuotes) {
                    currentRow.push(currentVal); currentVal = '';
                } else if (char === '\n' && !insideQuotes) {
                    currentRow.push(currentVal); rows.push(currentRow); currentRow = []; currentVal = '';
                } else { currentVal += char; }
            }
            if (currentVal || currentRow.length > 0) { currentRow.push(currentVal); rows.push(currentRow); }
            return rows;
        }

        function arrayToCSV(rows, separator) {
            return rows.map(row => row.map(val => {
                val = val === null || val === undefined ? '' : String(val);
                if (val.includes(separator) || val.includes('"') || val.includes('\n')) return `"${val.replace(/"/g, '""')}"`;
                return val;
            }).join(separator)).join('\n');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob(["\uFEFF" + content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- ЭКСПОРТ (БЕЗ ИЗМЕНЕНИЙ) ---
        function processExport() {
            clearLog();
            const fileInput = document.getElementById('sourceFileExport');
            const separator = document.getElementById('sepExport').value;
            if (!fileInput.files.length) { log("Файл не выбран", '#f55'); return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                const data = parseCSV(e.target.result, separator);
                const outputRows = [['Key', 'English_US', 'Description', 'Russian']];
                let currentItem = null;
                
                for (let i = 0; i < data.length; i++) {
                    const row = data[i];
                    if (row.length < 2) continue;
                    const keyName = cleanStr(row[0]).toLowerCase();
                    const value = row[1];

                    if (keyName === 'key') {
                        if (currentItem) outputRows.push([currentItem.key, currentItem.en, currentItem.desc, currentItem.ru]);
                        currentItem = { key: cleanStr(value), en: '', desc: '', ru: '' };
                    } else if (currentItem) {
                        if (keyName === 'english_us') currentItem.en = value;
                        else if (keyName === 'description') currentItem.desc = value;
                        else if (keyName === 'russian') currentItem.ru = value;
                    }
                }
                if (currentItem) outputRows.push([currentItem.key, currentItem.en, currentItem.desc, currentItem.ru]);
                
                log(`Экспортировано ключей: ${outputRows.length - 1}`, '#0f0');
                downloadCSV(arrayToCSV(outputRows, separator), 'table_for_edit.csv');
            };
            reader.readAsText(fileInput.files[0]);
        }

        // --- СЛИЯНИЕ (ОБНОВЛЕННОЕ: Учитывает En, Desc и Ru) ---
        function processMerge() {
            clearLog();
            log("Начинаю полное обновление...");
            const origInput = document.getElementById('originalFileImport');
            const transInput = document.getElementById('translatedFileImport');
            const separator = document.getElementById('sepImport').value;

            if (!origInput.files.length || !transInput.files.length) { log("Выберите оба файла!", '#f55'); return; }

            const readerOrig = new FileReader();
            readerOrig.onload = function(eOrig) {
                const origData = parseCSV(eOrig.target.result, separator);
                
                const readerTrans = new FileReader();
                readerTrans.onload = function(eTrans) {
                    const transData = parseCSV(eTrans.target.result, separator);
                    
                    if (transData.length < 1) { log("Файл перевода пуст", '#f55'); return; }

                    // Определяем колонки в таблице перевода
                    const header = transData[0].map(h => cleanStr(h).toLowerCase());
                    const idxKey = header.indexOf('key');
                    const idxEn = header.indexOf('english_us');
                    const idxDesc = header.indexOf('description');
                    const idxRu = header.indexOf('russian');

                    if (idxKey === -1) { log("Ошибка: В файле перевода нет колонки Key", '#f55'); return; }

                    // Создаем карту обновлений: Key -> { en, desc, ru }
                    const updatesMap = new Map();
                    for (let i = 1; i < transData.length; i++) {
                        const row = transData[i];
                        const key = cleanStr(row[idxKey]);
                        if (!key) continue;

                        updatesMap.set(key, {
                            en: idxEn !== -1 ? row[idxEn] : null,
                            desc: idxDesc !== -1 ? row[idxDesc] : null,
                            ru: idxRu !== -1 ? row[idxRu] : null
                        });
                    }
                    log(`Загружено ключей для обновления: ${updatesMap.size}`, '#0f0');

                    // Проходим по оригиналу
                    let currentKeyID = null;
                    let updatedCount = 0;

                    for (let i = 0; i < origData.length; i++) {
                        const row = origData[i];
                        if (row.length < 1) continue;
                        
                        const rowType = cleanStr(row[0]); 
                        const rowTypeLower = rowType.toLowerCase();

                        // 1. Нашли строку с Ключом
                        if (rowTypeLower === 'key') {
                            if (row.length > 1) currentKeyID = cleanStr(row[1]);
                        }

                        // 2. Если мы внутри известного ключа, проверяем типы полей
                        if (currentKeyID && updatesMap.has(currentKeyID)) {
                            const updates = updatesMap.get(currentKeyID);
                            let newValue = null;

                            // Проверяем, что за строка перед нами, и есть ли для нее обновление
                            if (rowTypeLower === 'english_us' && updates.en !== null) {
                                newValue = updates.en;
                            } else if (rowTypeLower === 'description' && updates.desc !== null) {
                                newValue = updates.desc;
                            } else if (rowTypeLower === 'russian' && updates.ru !== null) {
                                newValue = updates.ru;
                            }

                            // Если есть что обновить
                            if (newValue !== null) {
                                if (row.length < 2) row.push(newValue);
                                else {
                                    // Сравним, изменилось ли значение (чтобы не считать лишние обновления)
                                    // Но если вы хотите перезаписать принудительно, можно убрать if
                                    if (row[1] !== newValue) {
                                        row[1] = newValue;
                                        updatedCount++;
                                    }
                                }
                            }
                        }
                    }

                    log(`Успешно обновлено ячеек: ${updatedCount}`, '#0f0');
                    downloadCSV(arrayToCSV(origData, separator), 'fully_updated_file.csv');
                };
                readerTrans.readAsText(transInput.files[0]);
            };
            readerOrig.readAsText(origInput.files[0]);
        }
    </script>
</body>
</html>